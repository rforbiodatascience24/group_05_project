---
title: "Project"
author: "Miguel Blanco"
format: html
editor: visual
---

### Load libraries

```{r, warning=FALSE, message=FALSE}
library(tidyverse)
library(readxl)
library(stringr)

```

Load Data

```{r, warning=FALSE, message=FALSE}
data <- read_tsv("../data/01_dat_load.tsv")


```

Change values \[null\] for NAs

```{r}

#Notice that na_if function has to work with the same type of values at the time. For example in this df we have both character and numeric values, so we have to do it in 2 times


#The function takes the data (data) and the vector of all the values that we want to be considered as NAs (na_vector). This na_vector should be specified as 
# c("null", "-"...)
NA_values_replace <- function(data, na_vector){
  data |> 
    mutate(across(where(is.character), ~ case_when 
          (. %in% na_vector ~ NA,
          TRUE ~ .
          )))
}

data <- NA_values_replace(data = data, 
                          na_vector = c("[null]", "/", "-"))

```

Proportions of NA in each column

```{r}

#The function takes the data as only argument and return the proportion of NA values of each column in the data 
NA_prop <- function(data) {
  data |> 
    select(where(anyNA)) |> 
    summarise(across(everything(), ~ mean(is.na(.)), .names = "{col}")) |> 
    pivot_longer(everything(), values_to = "na_proportion", names_to = "column")
}

data_NA_proportion <- NA_prop(data)
```

Filter out columns with > 0.95 of NAs (This columns are meant to split the data and are empty, the only values are notes about the patients)

```{r}
Title_columns <- data_NA_proportion |> 
  filter(na_proportion > 0.95) |>
  pull(column)
    
```

```{r}
data <- data |> 
  select(-all_of(Title_columns))
```

Change dirty columns with multiple values to clean binary columns

```{r}
#Change name to a shorter one for sintax conveniance
data_clean <- data |> 
  rename(Basic_diseases = `Basic diseases (1 hypertension, 2 diabetes, 3 cardiovascular diseases, 4 cerebrovascular diseases, 5 COPD, 6 immunodeficiency (such as AIDS, hormone, immunosuppressant use history), 7 malignant tumor, 8 other 9 chronic kidney disease`)
```

```{r}
data_clean2 <- data_clean |> 
  #este select es solo ara visualizar mejor
  #select(Number, Basic_diseases) |> 
  #crea varias filas para el mismo paciente, con un unico numero de Disease en cada uno
  separate_rows(Basic_diseases, sep = ",") |> 
  #nos aseguramos que ese valor sea numerico, y si no es numerico se asigna a cero
  mutate(Basic_diseases = as.numeric(Basic_diseases)) |> 
  pivot_wider(
    names_from = Basic_diseases, 
    values_from = Basic_diseases, 
    values_fn = ~1, 
    values_fill = list(Basic_diseases = 0)) |> 
  rename_with(~paste0("disease_", .))

data_clean2 <- data_clean2 |> 
  # Filtrar las filas donde disease_NA == 1
  mutate(across(starts_with("disease_"), 
                ~if_else(disease_NA == 1, NA, .))) |> 
  # Eliminar la columna disease_NA
  select(-disease_NA, -disease_0)

data_clean2 <- data_clean2 |> 
  rename_with(~ case_when(
    . == "disease_1" ~ "Hypertension",
    . == "disease_2" ~ "Diabetes",
    . == "disease_3" ~ "CVD",
    . == "disease_4" ~ "Cerebrovascular",
    . == "disease_5" ~ "COPD",
    . == "disease_6" ~ "Immunodeficiency",
    . == "disease_7" ~ "Malignant_tumor",
    . == "disease_8" ~ "Other",
    . == "disease_9" ~ "Chronic_Kidney",
    TRUE ~ .
  ), starts_with("disease_"))
```

```{r}
data_clean <- data_clean |> 
  #Creates a new row for each number separated by a comma in the basic diseases column. For example if patient 1 have diseases 1,2,3 it will create 3 rows for that patient   with the exact same values in every column except "Basic disease" column, where there will be one row with value 1, other with 2 and other with 3.
  separate_rows(Basic_diseases, sep = ",") |> 
  
  # Now it creates a column Disease with the name that correspond to the number in the   column "Basic Diseases"
  mutate(
    Disease = case_when(
      Basic_diseases == "1" ~ "Hypertension",
      Basic_diseases == "2" ~ "Diabetes",
      Basic_diseases == "3" ~ "CVD",
      Basic_diseases == "4" ~ "Cerebrovascular",
      Basic_diseases == "5" ~ "COPD",
      Basic_diseases == "6" ~ "Immunodeficiency",
      Basic_diseases == "7" ~ "Malignant_tumor",
      Basic_diseases == "8" ~ "Other",
      Basic_diseases == "9" ~ "Chronic_Kidney",
      TRUE ~ "No_Value"),
    #In case that the value of the column is NA we want an NA value, else a 1
    Value = ifelse(Basic_diseases == "No_Value", NA, 1)
  ) |> 
  
  #Now we use a pivot wider to transform rows in coulmns
  pivot_wider(
    #Creates a column with each of the names in Diseases (one for each disease)
    names_from = Disease,
    #Insert the value from the column value, that will be 1 for every row
    values_from = Value,
    #Fill the observations that dont have a "Value" with a 0, as this are the observations that dont have the illness
    values_fill = 0 
  ) |> 
  
  #Now we have more than one row for each "Number", as one row for each number in BasicDisease column was created. Now we want to group those rows so we have only one row per observation
  group_by(Number) |>
  #Summarise and select the highest value for the columns between Hypertension and other (Columns created from BasicDisease column). Only one of the rows will have number 1 for the disease (if the observation had that disease) so we summarising we choose the highest value
  summarise(across(Hypertension : Other, ~ max(.x)),
        #Summarise eliminates all the columns where is not working, so we need to call summarise on all columns so they stay in the final df. Not apply it on the BasicDisease columns so they are not duplicated
         across(!c(Hypertension : Other), ~ first(.), .names = "{.col}")) |>
  ungroup() |> 
  #If the No value column is NA, all the values for the BasicDiseases created columns get NA value
  mutate(across(Hypertension : Other, ~ ifelse(is.na(No_Value), NA, .))) |> 
  #Now that we have used the No_value column, we can drop it 
  select(-No_Value)
```
