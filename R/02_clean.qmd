---
title: "Project"
author: "Miguel Blanco"
format: html
editor: visual
---

### Load libraries

```{r, warning=FALSE, message=FALSE}
library(tidyverse)
library(readxl)
library(stringr)

```

Load Data

```{r, warning=FALSE, message=FALSE}
data <- read_tsv("../data/01_dat_load.tsv")


```

Change values \[null\] for NAs

```{r}

#Notice that na_if function has to work with the same type of values at the time. For example in this df we have both character and numeric values, so we have to do it in 2 times


#The function takes the data (data) and the vector of all the values that we want to be considered as NAs (na_vector). This na_vector should be specified as 
# c("null", "-"...)
NA_values_replace <- function(data, na_vector){
  data |> 
    mutate(across(where(is.character), ~ case_when 
          (. %in% na_vector ~ NA,
          TRUE ~ .
          )))
}

data <- NA_values_replace(data = data, 
                          na_vector = c("[null]", "/", "-"))

```

Proportions of NA in each column

```{r}

#The function takes the data as only argument and return the proportion of NA values of each column in the data 
NA_prop <- function(data) {
  data |> 
    select(where(anyNA)) |> 
    summarise(across(everything(), ~ mean(is.na(.)), .names = "{col}")) |> 
    pivot_longer(everything(), values_to = "na_proportion", names_to = "column")
}

data_NA_proportion <- NA_prop(data)
```




Change dirty columns with multiple values to clean binary columns

```{r}
#Change name to a shorter one for sintax conveniance
data_clean <- data |> 
  rename(Basic_diseases = `Basic diseases (1 hypertension, 2 diabetes, 3 cardiovascular diseases, 4 cerebrovascular diseases, 5 COPD, 6 immunodeficiency (such as AIDS, hormone, immunosuppressant use history), 7 malignant tumor, 8 other 9 chronic kidney disease`)
```

```{r}
data_clean2 <- data_clean |> 
  #este select es solo ara visualizar mejor
  #select(Number, Basic_diseases) |> 
  #crea varias filas para el mismo paciente, con un unico numero de Disease en cada uno
  separate_rows(Basic_diseases, sep = ",") |> 
  #nos aseguramos que ese valor sea numerico, y si no es numerico se asigna a cero
  mutate(Basic_diseases = as.numeric(Basic_diseases)) |> 
  pivot_wider(
    names_from = Basic_diseases, 
    values_from = Basic_diseases, 
    values_fn = ~1, 
    values_fill = list(Basic_diseases = 0)) |> 
  rename_with(~paste0("disease_", .))

data_clean2 <- data_clean2 |> 
  # Filtrar las filas donde disease_NA == 1
  mutate(across(starts_with("disease_"), 
                ~if_else(disease_NA == 1, NA, .))) |> 
  # Eliminar la columna disease_NA
  select(-disease_NA, -disease_0)

data_clean2 <- data_clean2 |> 
  rename_with(~ case_when(
    . == "disease_1" ~ "Hypertension",
    . == "disease_2" ~ "Diabetes",
    . == "disease_3" ~ "CVD",
    . == "disease_4" ~ "Cerebrovascular",
    . == "disease_5" ~ "COPD",
    . == "disease_6" ~ "Immunodeficiency",
    . == "disease_7" ~ "Malignant_tumor",
    . == "disease_8" ~ "Other",
    . == "disease_9" ~ "Chronic_Kidney",
    TRUE ~ .
  ), starts_with("disease_"))
```

```{r}
data_clean <- data_clean |> 
  #Creates a new row for each number separated by a comma in the basic diseases column. For example if patient 1 have diseases 1,2,3 it will create 3 rows for that patient   with the exact same values in every column except "Basic disease" column, where there will be one row with value 1, other with 2 and other with 3.
  separate_rows(Basic_diseases, sep = ",") |> 
  
  # Now it creates a column Disease with the name that correspond to the number in the   column "Basic Diseases"
  mutate(
    Disease = case_when(
      Basic_diseases == "1" ~ "Hypertension",
      Basic_diseases == "2" ~ "Diabetes",
      Basic_diseases == "3" ~ "CVD",
      Basic_diseases == "4" ~ "Cerebrovascular",
      Basic_diseases == "5" ~ "COPD",
      Basic_diseases == "6" ~ "Immunodeficiency",
      Basic_diseases == "7" ~ "Malignant_tumor",
      Basic_diseases == "8" ~ "Other",
      Basic_diseases == "9" ~ "Chronic_Kidney",
      TRUE ~ "No_Value"),
    #In case that the value of the column is NA we want an NA value, else a 1
    Value = ifelse(Basic_diseases == "No_Value", NA, 1)
  ) |> 
  
  #Now we use a pivot wider to transform rows in coulmns
  pivot_wider(
    #Creates a column with each of the names in Diseases (one for each disease)
    names_from = Disease,
    #Insert the value from the column value, that will be 1 for every row
    values_from = Value,
    #Fill the observations that dont have a "Value" with a 0, as this are the observations that dont have the illness
    values_fill = 0 
  ) |> 
  
  #Now we have more than one row for each "Number", as one row for each number in BasicDisease column was created. Now we want to group those rows so we have only one row per observation
  group_by(Number) |>
  #Summarise and select the highest value for the columns between Hypertension and other (Columns created from BasicDisease column). Only one of the rows will have number 1 for the disease (if the observation had that disease) so we summarising we choose the highest value
  summarise(across(Hypertension : Other, ~ max(.x)),
        #Summarise eliminates all the columns where is not working, so we need to call summarise on all columns so they stay in the final df. Not apply it on the BasicDisease columns so they are not duplicated
         across(!c(Hypertension : Other), ~ first(.), .names = "{.col}")) |>
  ungroup() |> 
  #If the No value column is NA, all the values for the BasicDiseases created columns get NA value
  mutate(across(Hypertension : Other, ~ ifelse(is.na(No_Value), NA, .))) |> 
  #Now that we have used the No_value column, we can drop it 
  select(-No_Value)
```

```{r}
rename_map <- c(
  "disease_1" = "Hypertension",
  "disease_2" = "Diabetes",
  "disease_3" = "CVD",
  "disease_4" = "Cerebrovascular",
  "disease_5" = "COPD",
  "disease_6" = "Immunodeficiency",
  "disease_7" = "Malignant_tumor",
  "disease_8" = "Other",
  "disease_9" = "Chronic_Kidney"
)

process_diseases <- function(data, column, prefix, rename_map) {
  data_processed <- data |> 
    # Crear varias filas para cada valor en la columna separada por comas
    separate_rows({{ column }}, sep = ",") |> 
    # Asegurarse de que los valores sean numéricos, asignando 0 si no lo son
    mutate({{ column }} := as.numeric({{ column }})) |> 
    # Expandir las filas a columnas con indicadores binarios
    pivot_wider(
      names_from = {{ column }}, 
      values_from = {{ column }}, 
      values_fn = ~1, 
      values_fill = list(column = 0)
    ) |> 
    # Renombrar las columnas con el prefijo especificado
    #rename_with(~paste0(prefix, .), cols = length(names(data)):length(names(data))+length(rename_map))
    rename_with(
      ~paste0(prefix, .), 
      cols = tail(names(.), 9)  # Renombrar solo las últimas 9 columnas
    )  |> 
    # Filtrar valores NA si la columna correspondiente existe
    #mutate(across(starts_with(prefix), ~if_else(get(paste0(prefix, "NA")) == 1, NA, .))) |> 
    # Eliminar las columnas no deseadas
    select(-matches(paste0(prefix, "NA")), -matches(paste0(prefix, "0"))) |> 
    # Renombrar columnas según el mapa proporcionado
    rename_with(~ case_when(
      . %in% names(rename_map) ~ rename_map[.],
      TRUE ~ .
    ), starts_with(prefix)) |> 
        rename_with(
      ~gsub(paste0("^", prefix), "", .),  # Elimina el prefijo "disease_" si está presente
      starts_with(prefix)  # Aplica solo a columnas que empiezan con "disease_"
    ) 
  
  return(data_processed)
}

data_clean3 <- process_diseases(data_clean, Basic_diseases, "disease_", rename_map)
  
```

```{r}
#ESTO ES LO QUE HA HECHO CHATGPT
process_diseases <- function(data, column, rename_map) {
  
  # Crear los nombres de enfermedades según el número en la columna
  rename_map_full <- setNames(rename_map, as.character(1:length(rename_map)))
  
  data_processed <- data |> 
    # Separa las filas por la columna de enfermedades
    separate_rows({{ column }}, sep = ",") |> 
    
    # Crea una nueva columna con los nombres de las enfermedades
    mutate(
      Disease = case_when(
        as.character({{ column }}) %in% names(rename_map_full) ~ rename_map_full[as.character({{ column }})],
        TRUE ~ "No_Value"
      ),
      # Si el valor de Disease es No_Value, lo marcamos como NA, sino, lo dejamos como 1
      Value = ifelse(Disease == "No_Value", NA, 1)
    ) |> 
    
    # Usamos pivot_wider para transformar las filas en columnas
    pivot_wider(
      names_from = Disease,
      values_from = Value,
      values_fill = 0
    ) |> 
    
    # Agrupar por número (se asume que existe una columna 'Number')
    group_by(Number) |> 
    # Resumir seleccionando el valor máximo para cada enfermedad
    summarise(across(all_of(rename_map), ~ max(.x, na.rm = TRUE)),
              # También necesitamos mantener las demás columnas sin cambios
              across(!all_of(rename_map), ~ first(.), .names = "{.col}")) |> 
    ungroup() |> 
    # Si la columna "No_Value" tiene NA, entonces poner NA en todas las columnas de enfermedades
    mutate(across(all_of(rename_map), ~ ifelse(is.na(No_Value), NA, .))) |> 
    # Eliminar la columna No_Value
    select(-No_Value)
  
  return(data_processed)
}

# Ejemplo de uso
nombres <- c("Hypertension", "Diabetes", "CVD", "Cerebrovascular", "COPD", 
             "Immunodeficiency", "Malignant_tumor", "Other", "Chronic_Kidney")

data_clean2 <- process_diseases(data_clean, "Basic_diseases", nombres)
```
